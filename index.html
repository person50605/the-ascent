
<!DOCTYPE html>
<html>


<!-- these divs are here to enable storing information between functions -->

  <div id="invlpad"style="display:none;"></div>
  <div id="invtpad"style="display:none;"></div>
  <div id="eqlpad"style="display:none;"></div>
  <div id="eqtpad"style="display:none;"></div>
  <div id="invlen"style="display:none;"></div>
  <div id="disp_obj"style="display:none;"></div>
  <div id="room_name"style="display:none;"></div>
  <div id="room_desc"style="display:none;"></div>
  
  <div id="x"> hi</div>
  <div id="y"> hello</div>
  <div id="mousex"> mouse x </div>
  <div id="mousey"> mouse y </div>
  <div id="mouseh"> mouse h </div>
  <div id="debug"> debug</div>
  <div id="status names"> helloo</div>
  <div id="statuses"> helllo</div>


<!-- functions and vars -->
<script>
//vars

//I like my arrays to start at 1, so there's a placeholder "error" at the start of each one




//player statuses
//hopefully I don't misspell "player_status" as "player_stats"
player_status = [ ["error"],
//name
["error"],
//potency
["error"],
//duration (remaining)
["error"],
//source (you can't have the same effect from the same source more than once at a time)
["error"]

];

enemy_status = [ ["error"],
//name
["error"],
//potency
["error"],
//duration (remaining)
["error"],
//source
["error"]

];


//inventory
inv = [ ["error"],
//names`
["error","sword","iron helmet","shield","bread","health potion","phial of strength","fireball scroll"],
//quantities of the items
["error",1,2,3,1000,1000,1000,1000],
//modifications to the items (like xp or enchants)
["error"]
];


//equpped items - 12 slots
equipment = [["error"],
//name
//["error","cloak","helmet","neck","mainhand","body","offhand","ring","legs","ring","bag","feet","hands"],
["error","none","none","none","none","none","none","none","none","none","none","none","none"],
//quantity (useless, but here for consistency)
["error",1,1,1,1,1,1,1,1,1,1,1,1],
//modifications
["error"]
];


//item templates
items = [ ["error"],
//names
["error",
"sword",
"iron helmet",
"shield",
"bread",
"health potion",
"phial of strength"],
//descriptions
["error",
"A wooden sword",
"A helmet made of iron",
"A small buckler",
"a loaf of bread",
"a small potion that restores your health when imbibed.",
"a small phial of a liquid that increases your strength"
]


];



  /**   item tags    **/

equippable_stats = [ ["error"],
["error","sword","shield","iron helmet"],
["error","strength:2;dexterity:1","vitality:3;defence:10","vitality:5;defence:5"]

];






  //(
equippable_tags = [ ["error"],
//cloak
["error",
"ratskin cloak"
],
//helmets
["error",
"iron helmet",
"leather helmet"
],
//neck items
["error",
"silver necklace",
"gold necklace"
],
//mainhand items (usually weapons)
["error",
"sword",
"pickaxe"
],
//body armour
["error",
"plate armour",
"leather armour"
],
//offhand
["error",
"shield",
"tower shield"
],
//rings (two slots)
["error",
"wooden ring",
"iron ring"
],
//legs
["error",
"pants",
"jeans"
],
//bags (should increase quickslots)
["error",
"small pouch",
"bag of holding"
],
//feet
["error",
"swiftfoot boots",
"lightning greaves"
],
//hands (like gloves)
["error",
"gloves",
"gauntlets"
]

];
  //)

consumable_tags = [ ["error"],
//names
["error","bread","health potion","phial of strength","fireball scroll"],
/**
efects (target,type,effect:potency,duration) (effects are seperated by a semicolon)

target: (s)elf or (e)nemy
type: over (t)ime or (i)nstant
efect: name of the effect
potency: how strong the effect is.
duration: how many ticks the effect lasts, if effect is over time.
**/
["error","s,t,health regen:0.5,30","s,i,health:50","s,t,strength:1,100","e,i,health:-30;e,t,burn:1,20"]

];


  
  //(

//the player's (base) stats
//XXX: this list stores ONLY the base stats of the player. This is not reliable for 
//calculations that need to consider non-level-based stats (like damage dealt or recieved)
player_stats = [ ["error"],
//base stat names
["error","level","strength","dexterity","intelligence","charisma","luck","vitality","experience"], //1
//base stat values
["error",1,10,10,10,10,10,10,50], //2

//derived stat names (calculated on base stats)
//XXX: the health and mana values from this part of the array shouldn't be used
["error","health","max health","health regen","mana","max mana","mana regen","defence","mdefence"], //3
//derived stat values
["error",100,100,1,50,50,1,1,1], //4

//modded stats

//base stat values
["error",1,10,10,10,10,10,10], //5

//derived stat values (based on modded stats)
["error",100,100,1,50,50,1,1,1] //6

];
  //)
  
  //(
enemy_stats = [ ["error"],
//bstats
["error","level","strength","dexterity","intelligence","luck","vitality"], //1  enemies don't have cha
["error",1,10,10,10,10,10], //2

["error","health","max health","health regen","mana","max mana","mana regen","defence","mdefence"], //3
//additional modded stats
["error",100,100,1,50,50,1,1,1], //4

//mstats
["error",1,10,10,10,10,10], //5

["error",100,100,1,50,50,1,1,1],// //6
[0] //, //7 (xp value)

//stats gained per level, note that the first entry should be 0
//["error",0,0,0,0,0,0], //7
//["error",0,0,0,0,0,0,0,0] //8

]
  //)
  

enemy_template_stats = [ ["error"],
  /**
  name
  base stats ("level","strength","dexterity","intelligence","luck","vitality")
  error
  derived stats ("health","max health","health regen","mana","max mana","mana regen","defence","mdefence")
  base stats per level
  derived stats per level
  base xp value, xp value per level
  **/
  
  
["hog",

["error",0,12,7,2,10,14], //1 i=2  2
["error"], //2 i=3  don't read (3)
["error",0,0,0,0,0,0,2,0], //3 i=4  4
["error",0,2,1,0,0,0,2], //4 i=5  7
["error",0,10,0,0,0,0,0.2,0], //5 i=6  8
[10,5] //6
],

["wolf",

["error",0,11,15,5,10,10],
["error"],
["error",0,0,0,0,0,0,1,1],
["error",0,1,3,0,0,1],
["error",0,10,0.1,0,0,0,0,0],
[25,5]

],

["boar",

["error",0,14,7,1,10,15],
["error"],
["error",0,20,0,0,0,0,3,0],
["error",0,3,0,0,0,2],
["error",0,10,0,0,0,0,0.3,0],
[20,10]
]

]

  
  
//this is updated as the player moves
navigation = [["error"],
//displayed names
["error","go outside","go to bed"],
//button ids (names)
["error","travel","sleep"],
//extra data (if needed)
["error","town",undefined],
//more extra flags
["error",undefined,undefined]
];





player_location = "home";
combat_location = "error";

player_flags = [];

enemies_killed = 0
enemy_kill_requirement = 0
  
  
  
//declare functions

function updatestats() {

   //player_stats[5||6][X] should be used for most calculations
  //mstatus is a moddable status array(removing statuses doesn't actually remove them)

  for (let i=1;i<=player_stats[5].length-1;i++){//reset modded stats
      player_stats[5][i]=player_stats[2][i]
  }
    for (let i=1;i<=player_stats[6].length-1;i++){//set modded derived stats to 0
      if (i!=1 && i!=4){//but don't set hp & mp to 0
      player_stats[6][i]=0
      }
  }
  
  //Status calculations
  let mstatus = [["error"],["error"],["error"],["error"]];
  for (let i=0;i<=3;i++){//load up the temp. list
    let k = "error";
    for (let j=0;j<player_status[3].length;j++){
      k=player_status[i][j];
      mstatus[i][j]=k;
    }
  }
  for (let i=1; i<player_stats[1].length; i++) {//check for each -- base -- stat

    for (let l=1;mstatus[1].includes(player_stats[1][i]);l++) {
      let k=1;
      for (let j=1;player_stats[1][i] != mstatus[1][j] && j<=mstatus[1].length;j++) {//find the number of the status
        k=j;
      }
    player_stats[5][i]+=parseInt(mstatus[2][k]*100)/100; //round to the hundredth
    mstatus[1].splice(k,1);
    mstatus[2].splice(k,1);
    mstatus[3].splice(k,1);
    } 
  }
    

  for (let i=1; i<player_stats[3].length; i++) {//check for each -- derived -- stat

    for (let l=1;mstatus[1].includes(player_stats[3][i]);l++) {
      let k=1;
      for (let j=1;player_stats[3][i] != mstatus[1][j] && j<=mstatus[1].length;j++) {//find the number of the status
        k=j;
      }
    player_stats[6][i]+=parseInt(mstatus[2][k]*100)/100; //rounds to the nearest hundredth
    mstatus[1].splice(k,1);
    mstatus[2].splice(k,1);
    mstatus[3].splice(k,1);
    } 
  }
  
  
  
  //equipment calculations

  for (let i=1;i<=12;i++) {//check each equipped item  

    if (equipment[1][i] != "none") { //is there smth eq'd? 

      let en_num = 0
      for (let j=1;equippable_stats[1][j] != equipment[1][i] && equippable_stats[1][j] != undefined;j++) {//what id num is it?
        en_num = j
      }    
      
      //XXX: the above for loop ends one run early, so on_num has to be incremented.
      en_num++
      let eq_effect_store = equippable_stats[2][en_num]
      let eq_effects = ["error"]
      let eq_effect_params = [["error"]]
      let on_num = 0
      
      /** Effect finding **/
      for (let k=1;eq_effect_store[on_num] != undefined;k++){ //get all the effects
        eq_effects.push("")
        for (let l=0;eq_effect_store[on_num] != undefined && eq_effect_store[on_num] != ":";l++){//get effect name
          eq_effects[eq_effects.length-1] = eq_effects[eq_effects.length-1]+eq_effect_store[on_num]
          on_num++
        }

        on_num++
        
        eq_effect_params.push(["error"]) //create a new effect space
        
        for (let m=0;eq_effect_store[on_num] != ";" && eq_effect_store[on_num] !=undefined;m++){//get all parameters
          eq_effect_params[k].push("") //add a parameter space

          
          for (let n=0;eq_effect_store[on_num] !="," && eq_effect_store[on_num] !=";" && eq_effect_store[on_num] != undefined;n++){
            eq_effect_params[k][eq_effect_params[k].length-1] = eq_effect_params[k][eq_effect_params[k].length-1] + eq_effect_store[on_num] //edit the parameter
            on_num++
          }
          if (eq_effect_store[on_num] !=";"){
            on_num++
          }

        }
        
        on_num++
      }
      
      
      //Update stats
      for (let k=1;k<=eq_effects.length;k++) {
        if (player_stats[1].includes(eq_effects[k])){
          let stat_num=""
          for (let l=1;player_stats[1][l]!=eq_effects[k];l++){//is the effect a base stat?
            stat_num = l+1
          }
          player_stats[5][stat_num] += parseInt(eq_effect_params[k][1])
          
        } else if (player_stats[2].includes(eq_effects[k])) {//Or a derived stat?
          let stat_num=""
          for (let l=1;player_stats[2][l]!=eq_effects[k];l++){
            stat_num = l+1
          }
          player_stats[6][stat_num] += parseInt(eq_effect_params[k][1])
        } //TODO: Add more cases
        
        //TODO: add case for offensive combat effects & store them in another list
      }
      
      
      //Clear for the next item
      eq_effects = ["error"]
      eq_effect_params = [["error"]]
      eq_effects.splice(eq_effects.length-1,1) // XXX: I think this is redundant
      
    }
   
   }

  
  //translate the base stats into var names. Unnecessary, but helpful.
  let lvl = player_stats[2][1]
  let str = player_stats[2][2]
  let dex = player_stats[2][3]
  let int = player_stats[2][4]
  let cha = player_stats[2][5]
  let lck = player_stats[2][6]
  let vit = player_stats[2][7]
  /**
   Derived stats: hp, mhp, hp regen, mana, max mana, mana regen
    Subject to rebalancing.
   **/

  //(health)
  //max health
  player_stats[4][2] = 5*lvl + 10*vit
  //health regen (per tick)
  player_stats[4][3] = 1 + 0.1*vit
  //(mana)
  //max mana
  player_stats[4][5] = 5*lvl + 5*int
  //mana regen
  player_stats[4][6] = 1 + 1*int
  
  //level setting is probably unnecessary, but maybe there'll be smth that changes your level.
  lvl = player_stats[5][1]
  str = player_stats[5][2]
  dex = player_stats[5][3]
  int = player_stats[5][4]
  cha = player_stats[5][5]
  lck = player_stats[5][6]
  vit = player_stats[5][7]
  /**
   Derived stats: (hp,) mhp, hp regen, (mp,) max mp, mana regen
    Subject to rebalancing.
  **/

  //(health)
  //max health
  player_stats[6][2] += 5*lvl + 10*vit
  //health regen (per tick)
  player_stats[6][3] += 1 + 0.1*vit
  //(mana)
  //max mana

  player_stats[6][5] += 5*lvl + 5*int
  //mana regen
  player_stats[6][6] += 1 + 1*int
  //defence
  player_stats[6][7] += Math.round((1 + vit/20)*10)/10
  
  draweq(30,4,4,3);
  
  
  
}

function update_estats() {
   for (let i=1;i<=enemy_stats[5].length-1;i++){//reset modded stats
      enemy_stats[5][i]=enemy_stats[2][i]
  }
  for (let i=1;i<=enemy_stats[6].length-1;i++){//set modded derived stats to 0
    if (i!=1 && i!=4){//but don't set hp & mp to 0
      enemy_stats[6][i]=0
    }
  }

  //Status calculations
  let mstatus = [["error"],["error","error"],["error","error"],["error","error"]];

  for (let i=0;i<=3;i++){//load up the temp. list
    let k = "error";
    for (let j=0;j<enemy_status[3].length;j++){
      k=enemy_status[i][j];
      mstatus[i][j]=k;
    }
  }
  for (let i=1; i<enemy_stats[1].length; i++) {//check for each -- base -- stat

    for (let l=1;mstatus[1].includes(enemy_stats[1][i]);l++) {
      let k=1;
      for (let j=1;enemy_stats[1][i] != mstatus[1][j] && j<=mstatus[1].length;j++) {//find the number of the status
        k=j;
      }
    enemy_stats[5][i]+=parseInt(mstatus[2][k]*100)/100; //the statuses are stored in strings, so they need to be changed to ints
    mstatus[1].splice(k,1);
    mstatus[2].splice(k,1);
    mstatus[3].splice(k,1);
    } 
  }
  
  for (let i=1; i<enemy_stats[3].length; i++) {//check for each -- derived -- stat

    for (let l=1;mstatus[1].includes(enemy_stats[3][i]);l++) {
      let k=1;
      for (let j=1;enemy_stats[3][i] != mstatus[1][j] && j<=mstatus[1].length;j++) {//find the number of the status
        k=j;
      }
    enemy_stats[6][i]+=parseInt(mstatus[2][k]*100)/100; //rounds to the nearest hundredth
    mstatus[1].splice(k,1);
    mstatus[2].splice(k,1);
    mstatus[3].splice(k,1);
    } 
  }
  
  //equipment calculations
  
  //translate the base stats into var names. Unnecessary, but helpful.
  let lvl = enemy_stats[2][1]
  let str = enemy_stats[2][2]
  let dex = enemy_stats[2][3]
  let int = enemy_stats[2][4]
  let lck = enemy_stats[2][5]
  let vit = enemy_stats[2][6]
  /**
   Derived stats: hp, mhp, hp regen, mana, max mana, mana regen
    Subject to rebalancing.
   **/

  //(health)
  //max health
  enemy_stats[4][2] = 5*lvl + 10*vit
  //health regen (per tick)
  enemy_stats[4][3] = 1 + 0.1*vit
  //(mana)
  //max mana
  enemy_stats[4][5] = 5*lvl + 5*int
  //mana regen
  enemy_stats[4][6] = 1 + 1*int
  
  //level setting is probably unnecessary, but maybe there'll be smth that changes your level.
  lvl = enemy_stats[5][1]
  str = enemy_stats[5][2]
  dex = enemy_stats[5][3]
  int = enemy_stats[5][4]
  lck = enemy_stats[5][5]
  vit = enemy_stats[5][6]
  /**
   Derived stats: (hp,) mhp, hp regen, (mp,) max mp, mana regen
    Subject to rebalancing.
  **/

  //(health)
  //max health
  enemy_stats[6][2] += 5*lvl + 10*vit
  //health regen (per tick)
  enemy_stats[6][3] += 1 + 0.1*vit
  //(mana)
  //max mana
  enemy_stats[6][5] += 5*lvl + 5*int
  //mana regen
  enemy_stats[6][6] += 1 + 1*int
  //defence
  enemy_stats[6][7] += Math.round((1 + vit/20)*10)/10
  
  
  
}

function tick() {
  //Time controls & SBA's

  //decrease all status durations by one
  for (i=1;i<player_status[3].length;i++) {
    player_status[3][i]-=1;
    if (player_status[3][i] <= 0) {
      player_status[1].splice(i,1);
      player_status[2].splice(i,1);
      player_status[3].splice(i,1);
      //updatestats(); //already happening at the end of this function
    }
  }
  
  //regen player hp & mp
  let player_hp=player_stats[6][1];
  let player_regen=player_stats[6][3];
  let player_mhp=player_stats[6][2];
  let player_mp=player_stats[6][4];
  let player_mp_regen=player_stats[6][6];
  let player_mmp=player_stats[6][5];
  player_hp+=player_regen;
  if(player_hp>player_mhp) {
    player_hp=player_mhp;
  } else if(player_hp<=0) {
    //remove combat flag
    let on_num = -1
    for (let i=0;player_flags[i]!="in combat" && i<=player_flags.length;i++) {
      on_num=i
    }
    on_num++
    player_flags.splice(on_num,1)
    //send home
    player_location = "house"
    
    document.getElementById("room_name").innerHTML = player_location
    document.getElementById("room_desc").innerHTML = "Your house"
    navigation[1] = "go outside","go to bed"
    navigation[2] = "travel","sleep"
    navigation[3] = "town",undefined
    //redraw screen
    drawdisplay("nothing")
    drawnav()
    
  }
  player_mp+=player_mp_regen;
  if (player_mp>player_mmp){
    player_mp=player_mmp;
  }
  
  
  if (player_flags.includes("in combat")) { //regen enemy hp & mp
    let enemy_hp=enemy_stats[6][1];
    let enemy_regen=enemy_stats[6][3];
    let enemy_mhp=enemy_stats[6][2];
    let enemy_mp=enemy_stats[6][4];
    let enemy_mp_regen=enemy_stats[6][6];
    let enemy_mmp=enemy_stats[6][5];
    enemy_hp+=enemy_regen;
    if(enemy_hp>enemy_mhp) {
      enemy_hp=enemy_mhp;
    } else if(enemy_hp<=0) {
      enemies_killed++
      if (enemies_killed>=enemy_kill_requirement){
        //TODO: figure out what to put here
      } else {
        startcombat(combat_location,true);
        //drawdisplay();
        document.getElementById("status names").innerHTML = player_status[1];
        document.getElementById("statuses").innerHTML = player_status[3];
        updatestats();
        draweq(30,4,4,3);
        setTimeout(tick, 1000); //repeat the function
        return;
      }
      
    }
    enemy_mp+=enemy_mp_regen;
    if (enemy_mp>enemy_mmp){
      enemy_mp=enemy_mmp;
    }
    
    

    //do attacks
    //TODO: Turn this into a function
    let p_str = player_stats[5][2]
    let p_def = player_stats[6][7]
    if (p_def <=0){
      p_def = 0.1
    }
    
    let e_str = enemy_stats[5][2]
    let e_def = enemy_stats[6][7]
    if (e_def <=0){
      e_def = 0.1
    }

    let e_dmg =5*e_str*(3/((p_def+27)^(1/3))) - p_def
    if (e_dmg<0){
      e_dmg=0
    }
    player_hp-=e_dmg
    
    let p_dmg=5*p_str*(3/((p_def+27)^(1/3))) - e_def
    if(p_dmg<0){
      p_dmg=0
    }
  
    enemy_hp -= p_dmg
    
    console.log(p_dmg-enemy_regen)
    console.log(e_dmg-player_regen)
    enemy_stats[6][1]=Math.round(enemy_hp*100)/100;
    enemy_stats[6][3]=enemy_regen;
    enemy_stats[6][2]=enemy_mhp;
    enemy_stats[6][4]=Math.round(enemy_mp*100)/100;
    enemy_stats[6][6]=enemy_mp_regen;
    enemy_stats[6][5]=enemy_mmp;
    
    
    
    
    drawdisplay();
  }
  
  player_stats[6][1]=Math.round(player_hp*100)/100;
  player_stats[6][3]=player_regen;
  player_stats[6][2]=player_mhp;
  player_stats[6][4]=Math.round(player_mp*100)/100;
  player_stats[6][6]=player_mp_regen;
  player_stats[6][5]=player_mmp;
  
  
  document.getElementById("status names").innerHTML = player_status[1];
  document.getElementById("statuses").innerHTML = player_status[3];
  updatestats();
  draweq(30,4,4,3);
  setTimeout(tick, 1000); //repeat the function

}

function setestats(enemy,level){
  let nmy_num = 0;
  enemy_stats[2][1] = level;

  for (let i=0;enemy_template_stats[i][0]!=enemy;i++){
    nmy_num = i
  }
  nmy_num++
  enemy_stats[7][0] = enemy_template_stats[nmy_num][6][0] + (enemy_template_stats[nmy_num][6][1]*level)

  for(let i=2;i<=5;i++){
    
    if (i!=3){ //base stats
      for(let j=1;j<enemy_template_stats[nmy_num][i-1].length;j++){
        enemy_stats[i][j] = enemy_template_stats[nmy_num][i-1][j]
        if (i==2){
          enemy_stats[i][j] += enemy_template_stats[nmy_num][4][j]*level
        } else if (i==4){
          enemy_stats[i][j] += enemy_template_stats[nmy_num][5][j]*level
        }
      }
    }
  }
  
}

function startcombat(area,continuing) {

  if(!continuing){
  combat_location = area
  enemies_killed = 0
  player_flags.push("in combat");
  navigation[1].push("flee")
  navigation[2].push("travel")
  navigation[3].push(player_location)
  navigation[4][1] = "flee"
  }

  function getenemy(names,chances,nmy_lvls) { //randomly picks an enemy from the provided list
    
    let azar = 0.00000000000000001;
    for (let i = 0;i<=nombres.length;i++){
      azar += azares[i]
      if (enemy<=azar) {
        enemy = nombres[i]
        enemy_lvl = nmy_lvls[i] //Get it? nmy?
        break;
      }
    }
  }
  
  let nombres = ["error"]
  let azares = ["error"] //I know.
  let enemy = Math.random();
  let enemy_lvl = 1
  if (area == "forest_1") {//starting forest, next to town
    nombres = ["hog","wolf","boar"]
    azares = [0.65,0.25,0.1]
    niveles = [5,7,8]
    
    enemy_kill_requirement = 25
  }
  
  getenemy(nombres,azares,niveles);

  setestats(enemy,enemy_lvl);
  update_estats();
  enemy_stats[6][1]=enemy_stats[6][2] //make sure it doesn't spawn with 0 hp
  enemy_stats[6][4]=enemy_stats[6][5] //or 0 mana
  drawdisplay(enemy);
}



function activateButton() {
  //TODO: redraw the inv & eq on page load to saturate the last boxes
  let mx = document.getElementById("x").innerHTML;
  let my = document.getElementById("y").innerHTML;
  let hovering = 1;
  let invlpad = document.getElementById("invlpad").innerHTML;
  let invtpad = document.getElementById("invtpad").innerHTML;
  let eqlpad = document.getElementById("eqlpad").innerHTML;
  let eqtpad = document.getElementById("eqtpad").innerHTML;
  let b = 4;
  let d = 30;
  //onclick logic
  //TODO: make the inventory scroll buttons work
  if (mx<389 && mx>50 && my<550 && my>350) { //is the button in the inventory?
    //switch mx & my units to boxes
    mx = Math.ceil((mx-10-invlpad)/(b+d));
    my = Math.ceil((my-350-invtpad)/(b+d));
    hovering = (my-1)*10+mx;
    let eq_slot = false;
    let inv_slot = false;
    if (inv [2] [hovering] != undefined) {
        //code for equipping items
        if (equippable_tags.some(m=>m.includes(inv [1] [hovering]))) { //is the item equippable?
          for (let i=1;i<=12; i++) { //which slot does the item go in? 
            
            if (equippable_tags[i].includes(inv [1] [hovering])) {
              eq_slot = i;
              break;
            }
          
          }
          //TODO: make this work with rings
          if (equipment[1][eq_slot] != undefined) { //is there an item equipped in the slot?
            //adds the equipped item to the inventory
            if (equipment[3][eq_slot] != undefined) { //is the equipped item modified?
              //if so, just add the item in a new slot
              inv [1][inv[1].length+1] = equipment[1][eq_slot];
              
            } else if (inv[1].includes(equipment[1][eq_slot])) { //otherwise, does the inventory contain a copy of the item?
              for (let i=1;i<inv[1].length;i++){ //if so, which slot is it in?
                if (inv[1][i] == equipment[1][eq_slot]) {
                  inv_slot = i;
                  break;
                }
              }
              inv[2][inv_slot]+=1;
            }
           
          }
            inv[2][hovering] -= 1;
            equipment [1][eq_slot] = inv[1][hovering];
            equipment[3][eq_slot] = inv[3][hovering];
            
            if (inv[2][hovering] <= 0) { //delete so the inventory looks pretty
              inv[1].splice(hovering,1);
              inv[2].splice(hovering,1);
              inv[3].splice(hovering,1);            
            }
            updatestats();
        
        } 
        else if (consumable_tags.some(m=>m.includes(inv[1][hovering]))) {//can it be eaten?
          //remove the item
          inv[2][hovering] -= 1;
          let eat_effect = 0;
          for (let i = 1;i<consumable_tags[1].length;i++) { //find the effects of the item eaten as a raw string
            if (consumable_tags[1][i] == inv[1][hovering]) {
              eat_effect = consumable_tags[2][i]
              break;
            }
          }
          
          
          if (eat_effect != 0) { //is there an effect for this?
            let on_num = 0;
            let nom = "";
            let effect_type = "";
            let effect_name = "";
            //TODO: merge the enclosed for loops somehow and make all the effects from one item into one listed effect.
            //XXX: this code only works for items with eleven or less entries. To increase the limit, change or remove the m conditional.
            for (let m = 0; eat_effect[on_num] != undefined && m <= 10; m++) {//read all the effects
              
              if (eat_effect[on_num] == "s") {//is it targeting the player?
                on_num+=2;
                effect_type = eat_effect[on_num];
                
                on_num+=2;
                
              
                for (let i = 0; eat_effect[on_num] != ":"; i++) {//read the effect name
                  nom = nom + eat_effect[on_num]
                  on_num ++
                }
                
                if (effect_type == "t") {//is the effect over time?
                  if (player_status[4].includes(inv[1][hovering])) {
                    let foo = undefined
                    for (let i=0;player_status[4][i]!=inv[1][hovering];i++) {
                      foo = i
                    }
                    foo++
                    for (let i = 0; eat_effect[on_num] != ","; i++) {//skip the potency
                      on_num ++
                    }
                      
                    on_num ++
                    nom = "";
                    
                    for (let i = 0; eat_effect[on_num] != ";" && eat_effect[on_num] != undefined; i++) {//read the duration
                      nom = nom + eat_effect[on_num]
                      on_num ++
                    }
                    
                    player_status[3][foo] += parseInt(nom)
                    
                    
                    
                  }else {
                  
                    on_num++
                    player_status[1].push(nom);
                    player_status[4].push(inv[1][hovering])
                    nom = "";
                    for (let i = 0; eat_effect[on_num] != ","; i++) {//read the potency
                      nom = nom + eat_effect[on_num]
                      on_num ++
                    }
                      
                    on_num += 1;
                    player_status[2].push(nom);
                    nom = "";
                    
                    for (let i = 0; eat_effect[on_num] != ";" && eat_effect[on_num] != undefined; i++) {//read the duration
                      nom = nom + eat_effect[on_num]
                      on_num ++
                    }
                    on_num++
                    player_status[3].push(nom);
                    nom = "";
                  }
                } else if (effect_type == "i") {//is the effect instant?
                
                  effect_name = nom;
                  on_num++;
                  nom = "";
                  
                  for (let i = 0; eat_effect[on_num] != ";" && eat_effect[on_num] != undefined && i<=10; i++) {//read the potency
                    nom = nom + eat_effect[on_num]
                    on_num ++
                  }
                  //nested if statements for checking the effects
                  if (effect_name == "health") {
                    player_stats[6][1] += parseInt(nom);
                    if (player_stats[6][1] > player_stats[6][2]) {//no overflow health
                      player_stats[6][1] = player_stats[6][2];
                    }
                  }//TODO: add more cases for other effects
                  
                }
              }else if(eat_effect[on_num] == "e"){ //TODO: Add a cooldown to each item to prevent spamming
                on_num+=2;
                effect_type = eat_effect[on_num];
                
                on_num+=2;
                
              
                for (let i = 0; eat_effect[on_num] != ":"; i++) {//read the effect name
                  nom = nom + eat_effect[on_num]
                  on_num ++
                }
                
                if (effect_type == "t") {//is the effect over time?
                  if (enemy_status[4].includes(inv[1][hovering])) {
                    let foo = undefined
                    for (let i=0;enemy_status[4][i]!=inv[1][hovering];i++) {
                      foo = i
                    }
                    foo++
                    for (let i = 0; eat_effect[on_num] != ","; i++) {//skip the potency
                      on_num ++
                    }
                      
                    on_num ++
                    nom = "";
                    
                    for (let i = 0; eat_effect[on_num] != ";" && eat_effect[on_num] != undefined; i++) {//read the duration
                      nom = nom + eat_effect[on_num]
                      on_num ++
                    }
                    
                    enemy_status[3][foo] += parseInt(nom)
                    
                    
                    
                  }else {
                  
                    on_num++
                    enemy_status[1].push(nom);
                    enemy_status[4].push(inv[1][hovering])
                    nom = "";
                    for (let i = 0; eat_effect[on_num] != ","; i++) {//read the potency
                      nom = nom + eat_effect[on_num]
                      on_num ++
                    }
                      
                    on_num += 1;
                    enemy_status[2].push(nom);
                    nom = "";
                    
                    for (let i = 0; eat_effect[on_num] != ";" && eat_effect[on_num] != undefined; i++) {//read the duration
                      nom = nom + eat_effect[on_num]
                      on_num ++
                    }
                    on_num++
                    enemy_status[3].push(nom);
                    nom = "";
                  }
                } else if (effect_type == "i") {//is the effect instant?
                
                  effect_name = nom;
                  on_num++;
                  nom = "";
                  
                  for (let i = 0; eat_effect[on_num] != ";" && eat_effect[on_num] != undefined && i<=10; i++) {//read the potency
                    nom = nom + eat_effect[on_num]
                    on_num ++
                  }
                  //nested if statements for checking the effects
                  if (effect_name == "health") {
                    enemy_stats[6][1] += parseInt(nom);
                    enemy_stats[6][1] = parseInt(enemy_stats[6][1]*100)/100
                    if (enemy_stats[6][1] > enemy_stats[6][2]) {//no overflow health
                      enemy_stats[6][1] = enemy_stats[6][2];
                    }
                  }//TODO: add more cases for other effects
                  
                } 
                drawdisplay();
              }
              
              
              on_num++
            }
            
          }
          
          
          if (inv[2][hovering] <= 0) { //delete so the inventory looks pretty
              inv[1].splice(hovering,1);
              inv[2].splice(hovering,1);
              inv[3].splice(hovering,1);    
          }
        //updatestats();
        //draweq(30,4,4,3);
        }
    }
      
      
    //update the data
    document.getElementById("invlen").innerHTML = inv[2].length-1;
    document.getElementById("mousex").innerHTML = mx;
    document.getElementById("mousey").innerHTML = my;
    document.getElementById("mouseh").innerHTML = hovering;
    
  } else if (mx<164 && mx>62 && my<210 && my>74) { //is the button in the equipment area?
    //convert mousePos to boxes
    mx = Math.round((mx-eqlpad+b)/(b+d));
    my = Math.ceil((my-50-eqtpad-b)/(b+d));
    //which box is being clicked?
    hovering = (my-1)*3+mx;
    if (equipment [2] [hovering] == undefined) {
      equipment [2] [hovering] = 1;
    } else {
      equipment [2] [hovering] = equipment [2] [hovering] + 1;
    }
    document.getElementById("invlen").innerHTML = inv[2].length-1;
    document.getElementById("mousex").innerHTML = mx;
    document.getElementById("mousey").innerHTML = my;
    document.getElementById("mouseh").innerHTML = hovering;
  
  
    
  
    
  
  } else if (mx<761 && mx>469 && my<(429+navigation[1].length*25) && my>429) {//is it in the navigation panel; specifically, the buttons?
    let mh = Math.ceil((my-430)/25);
    document.getElementById("mouseh").innerHTML=mh;
    if (navigation[2][mh] == "travel") { //moves the player to a new location
     
      if (navigation[4][mh] =="flee") {
        let on_num = -1
        for (let i=0;player_flags[i]!="in combat" && i<=player_flags.length;i++) {
          on_num=i
        }
        on_num++
        player_flags.splice(on_num,1)
        drawdisplay("nothing");
      }

      player_location = navigation[3][mh]; // this is the new location
      document.getElementById("room_name").innerHTML = player_location
      //clear the button options
      navigation[1].splice(1,navigation[1].length); //I believe the second parameter is unnecessary
      navigation[2].splice(1,navigation[2].length);
      navigation[3].splice(1,navigation[3].length);
      if (player_location == "town"){
        document.getElementById("room_desc").innerHTML = "A bustling town"
        navigation[1].push("go to your house","go into the forest","throw a coin into the fountain")
        navigation[2].push("travel","travel","fountain_coin")
        navigation[3].push("house","forest",undefined)
      } else if (player_location == "house") {
        document.getElementById("room_desc").innerHTML = "Your house"
        navigation[1].push("go outside","go to bed")
        navigation[2].push("travel","sleep")
        navigation[3].push("town",undefined)
      } else if (player_location == "forest") {
        document.getElementById("room_desc").innerHTML = "A tranquil forest"
        navigation[1].push("return to town","go hunting")
        navigation[2].push("travel","combat")
        navigation[3].push("town","forest_1")
      }
    
      
      
    } else if (navigation[2][mh] == "combat") {
      let foo = navigation[3][mh] //This line is necessary
      navigation[1].splice(1,navigation[1].length);
      navigation[2].splice(1,navigation[2].length);
      navigation[3].splice(1,navigation[3].length);
      
      startcombat(foo,false);
    
    }//TODO: add more button cases
   
    
  }
    //redraw (the relevant parts of) the screen
    drawinv(30,4,6,10);
    draweq(30,4,4,3);
    drawnav();
}

function drawinv(d,b,h,w) {
  //d is the size of the boxes
  //b is the amount of space between boxes
  //h is the height of the inventory (in boxes) (should be 4)
  //w is the width of the inventory (in boxes) (should be 3)
  var c = document.getElementById("inventory");
  var ctx = c.getContext("2d");
  let tpad = 0;
  let lpad = 50;
  document.getElementById("invtpad").innerHTML = tpad;
  document.getElementById("invlpad").innerHTML = lpad;
  ctx.clearRect(0, 0, 450, 300);
  ctx.strokeStyle = "black";
  ctx.font = "10px Arial";
      //draw the buttons for scrolling
      //TODO: space the buttons correctly and make the arrows have the same dimensions
      //up button
      ctx.rect(400,64,d,d)
      ctx.moveTo(415, 71);
      ctx.lineTo(425, 87);
      ctx.lineTo(405, 87);
      ctx.lineTo(415, 71);

      //down button
      ctx.rect(400,114,d,d)
      ctx.moveTo(415, 137);
      ctx.lineTo(425, 120);
      ctx.lineTo(405, 120);
      ctx.lineTo(415, 137);
      
  //draw the inventory
  for (n=0; n<h; n++) {
    for (i=0; i<w; i++) {
      //draw the boxes
      ctx.rect((b+d)*i+b+lpad,(b+d)*n+b+tpad,d,d);
      //add the item quantity
      if (inv [2] [n*10+i+1] != undefined) {
      ctx.fillText(inv [2] [n*10+i+1],(b+d)*(i+1)-d+1+lpad, (b+d)*n+b+d-2+tpad);
      }
      //add the item name
      //TODO: make this code load an image instead of text
      if (inv [1] [n*10+i+1] != undefined) {
      ctx.fillText(inv [1] [n*10+i+1],(b+d)*(i+1)-d+2+lpad, (b+d)*n+b+d/2+tpad);
      }
      ctx.stroke();
    }
  }
}

function draweq (d,b,h,w) {
  var c = document.getElementById("eq");
  var ctx = c.getContext("2d");
  ctx.clearRect(0, 0, 450, 200);
  ctx.strokeStyle = "black";
  ctx.font = "10px Arial";
  ctx.fillStyle = "black";
  ctx.textAlign = "center";
  let tpad = 20;
  let lpad = 50;
  document.getElementById("eqtpad").innerHTML = tpad;
  document.getElementById("eqlpad").innerHTML = lpad;
  /** equipment **/
  //draw the eq boxes
  for (let n=0; n<h; n++) {
    for (let i=0; i<w; i++) {
      //draw the boxes
      ctx.rect((b+d)*i+b+lpad, (b+d)*n+b+tpad,d,d);
      if (equipment [1] [n*3+i+1] != undefined) {//show "images"
        ctx.fillText(equipment[1][n*3+i+1], (b+d)*(i+1)-d/2+lpad, (b+d)*n+b+d/2+tpad);
      }
      ctx.stroke();
    }
  }

  /** stat box **/
  ctx.rect(170,24,180,132);
  ctx.rect(170,40,180,0); //draw a line
  //hp & mp bar outlines
  ctx.rect(178,44,80,12); //hp
  ctx.rect(262,44,80,12); //mp
  //draw xp bar
  ctx.moveTo(178, 60); 
  ctx.lineTo(215, 60);
  ctx.lineTo(225, 64);
  ctx.lineTo(343, 64);
  ctx.lineTo(343,72);
  ctx.lineTo(178, 72);
  ctx.lineTo(178, 60);
  //fill the bars
  ctx.fillStyle = "green"
  ctx.fillRect(178,44,80*(player_stats[6][1]/player_stats[6][2]),12) //hp
  ctx.fillStyle = "CornflowerBlue"
  ctx.fillRect(262,44,80*(player_stats[6][4]/player_stats[6][5]),12) //mp
  ctx.fillStyle = "magenta"
  ctx.fillRect(178,60,150*(player_stats[2][8]/(player_stats[2][1]*100)),12) //xp
  //clear the overflowing part of the bar
  ctx.clearRect(216,60,165,1)
  ctx.clearRect(217,61,174,1)
  ctx.clearRect(220,62,173,1)
  
  ctx.fillStyle = "black" //reset the colour
  ctx.fillText(player_stats[6][1]+"/"+player_stats[6][2],218,54) //hp
  ctx.fillText(player_stats[6][4]+"/"+player_stats[6][5],302,54) //mp
  
  ctx.strokeStyle="black";
  ctx.font="Arial 16px";
  ctx.fillText("Stats",260,35);
  ctx.font="Arial 8px";
  ctx.textAlign = "left";
  ctx.fillText("Lv:"+player_stats[2][1],180,70);
  ctx.textAlign = "center";
  //Base Stats
  for (let i=2;i<player_stats[1].length-1;i++){
     ctx.fillText(player_stats[1][i],194+55*(i-2)-165*Math.floor((i-2)/3),84+40*Math.floor((i-2)/3));
  }
 for (let i=2;i<=player_stats[5].length-1;i++){
     ctx.fillText(player_stats[5][i],194+55*(i-2)-165*Math.floor((i-2)/3),104+40*Math.floor((i-2)/3));
  }
  ctx.stroke();
  //status circles
  for (let i=1;i<player_status[1].length;i++){
    ctx.beginPath();
    ctx.arc(lpad+b+5+14*(i-1), tpad+(b+d)*4+10, 5, 0, 2 * Math.PI);
    ctx.fillText(player_status[1][i],lpad+b+5+14*(i-1), tpad+(b+d)*4+13)//TODO: load image here
    ctx.stroke();
  }
  //stop the annoying extra bold outline
  ctx.beginPath();
  ctx.stroke();
  
}

function drawdisplay(newobj){
  var c = document.getElementById("display");
  var ctx = c.getContext("2d");
  ctx.clearRect(0, 0, 300, 300);
  ctx.strokeStyle = "black";
  ctx.font="10px Arial";
  if (newobj != undefined) { //keep the current object if there's no newobj parameter
    document.getElementById("disp_obj").innerHTML = newobj;
  }
  disp_obj =  document.getElementById("disp_obj").innerHTML;
  //if (disp_obj != "nothing") { //XXX: when images are implemented, activate this code
    ctx.fillText(disp_obj, 125,125);
  //}
  
  if (player_flags.includes("in combat")) {
    ctx.font = "10px Arial";
    ctx.fillStyle = "black";
    ctx.textAlign = "right";

    ctx.beginPath();
    //kill count & requirement
    ctx.fillText("Kills: "+enemies_killed+"/"+enemy_kill_requirement,289,288) //lvl XXX: level is going to be inconsistently referred to as lv & lvl
    ctx.textAlign = "center";

    //hp & mp bar outlines
    ctx.rect(50,44,80,12); //hp
    ctx.rect(135,44,80,12); //mp
    //fill the bars
    ctx.fillStyle = "green"
    ctx.fillRect(50,44,80*(enemy_stats[6][1]/enemy_stats[6][2]),12) //hp
    ctx.fillStyle = "CornflowerBlue"
    ctx.fillRect(135,44,80*(enemy_stats[6][4]/enemy_stats[6][5]),12) //mp
    //numbers
    ctx.fillStyle = "black";
    ctx.fillText(enemy_stats[6][1]+"/"+enemy_stats[6][2],90,54) //hp
    ctx.fillText(enemy_stats[6][4]+"/"+enemy_stats[6][5],175,54) //mp
    ctx.textAlign = "left";
    ctx.fillText("Lv:"+enemy_stats[2][1],50,70) //lvl XXX: level is going to be inconsistently referred to as lv & lvl
    ctx.stroke();
    //status circles
    ctx.textAlign = "center";
    for (let i=1;i<enemy_status[1].length;i++){
      ctx.beginPath();
      ctx.arc(80+14*(i-1), 66, 5, 0, 2 * Math.PI);
      ctx.fillText(enemy_status[1][i],80+14*(i-1), 70)//TODO: load image here
      ctx.stroke();
    }
    
    //stop the annoying extra bold outline
    ctx.beginPath();
    ctx.stroke();
  }
}

function n_percent_chance(percent){
  if(Math.random(1,100)<=percent){
    return true
  } else{
    return false
  }
}

function drawnav(){
  var c = document.getElementById("nav");
  var ctx = c.getContext("2d");
   ctx.clearRect(0, 0, 300, 290);
   ctx.beginPath();
  //room name XXX: it may be better to draw this after the description so the bottom line isn't drawn over by the desc box
  let rm_name = document.getElementById("room_name").innerHTML
  ctx.rect(-1,0,450,30);
  ctx.font="Arial 15px"
  ctx.strokeStyle="black"
  ctx.textAlign="center"
  //room name
  ctx.fillText(rm_name,nav.width/2,10);
  ctx.font="Arial 10px"
  ctx.stroke();
  //room description
  let rm_dsc = document.getElementById("room_desc").innerHTML

  ctx.strokeStyle = "grey";
  ctx.fillStyle = "gray";
  ctx.rect(-1,30,450,50);
  ctx.stroke();
  ctx.fillText(rm_dsc,nav.width/2,40);
  ctx.stroke();
  ctx.strokeStyle="DimGray";
  ctx.fillStyle = "black";

  for (let i=1;i<navigation[1].length;i++) {
    ctx.rect(-1,80+(i-1)*25,450,25);
    ctx.fillText(navigation[1][i],nav.width/2,90+(i-1)*25);
  }
  ctx.stroke();
}

function updateMousePos(event) {
  pageX.innerText = event.pageX;
  pageY.innerText = event.pageY;
}

//constant mouse tracking
const pageX = document.getElementById("x");
const pageY = document.getElementById("y");







</script>






<!-- Page setup -->
<canvas>
  <head style="position:fixed;left:100px;top:200px">The Ascent</head>
</canvas>

<p>

  <button onclick="findstr()"> click me </button>

</p>
    
<p>
  <div id="per" onclick="change()"> str </div>

</p>




<!-- Equipment drawing -->
<!--XXX: the canvas height should be 275, but it was temporarily changed for debugging reasons-->
<canvas id="eq" height="290" width="450"
style="border:1px solid #000000;position:fixed;left:10px;top:50px">
  <script>
  eq.addEventListener("mousemove", updateMousePos);
  eq.addEventListener("mouseenter", updateMousePos);
  eq.addEventListener("mouseleave", updateMousePos);
  eq.addEventListener("click", activateButton);
  var c = document.getElementById("eq");
  var ctx = c.getContext("2d");
  draweq(30,4,4,3);
  tick();
  </script>
</canvas>

<!-- Inventory drawing -->
<canvas id="inventory" height="300" width="450" 
style="border:1px solid #000000;position:fixed;left:10px;top:350px">

  <script>
  inventory.addEventListener("mousemove", updateMousePos);
  inventory.addEventListener("mouseenter", updateMousePos);
  inventory.addEventListener("mouseleave", updateMousePos);
  inventory.addEventListener("click", activateButton);
    var c = document.getElementById("inventory");
    var ctx = c.getContext("2d");
    drawinv(30,4,6,10);
  </script>
  
</canvas>

<!-- display -->

<canvas id="display" height="290" width="290" 
style="border:1px solid #000000;position:fixed;left:470px;top:50px">
  <script>
    var c = document.getElementById("display");
    var ctx = c.getContext("2d");
    drawdisplay("nothing");
  </script>

</canvas>

<!-- navigation -->

<canvas id="nav" height="300" width="290" 
style="border:1px solid #000000;position:fixed;left:470px;top:350px">
  <script>
    document.getElementById("room_name").innerHTML="House"
    document.getElementById("room_desc").innerHTML="Your house"
    nav.addEventListener("mousemove", updateMousePos);
    nav.addEventListener("mouseenter", updateMousePos);
    nav.addEventListener("mouseleave", updateMousePos);
    nav.addEventListener("click", activateButton);
    var c = document.getElementById("nav");
    var ctx = c.getContext("2d");
    drawnav();
  </script>
</canvas>

</html>
